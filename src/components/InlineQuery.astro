---
import { getCollection } from 'astro:content';

interface Props {
  placeholder?: string;
}

const { placeholder = "* FROM blog" } = Astro.props;

// Fetch all content at build time
const blog = await getCollection('blog', ({ data }) => !data.draft);
const projects = await getCollection('projects');
const links = await getCollection('links');

const contentData = {
  blog: blog.map(p => ({
    id: p.id,
    title: p.data.title,
    description: p.data.description,
    date: p.data.date.toISOString(),
    tags: p.data.tags || [],
    _url: `/blog/${p.id}`
  })),
  projects: projects.map(p => ({
    id: p.id,
    title: p.data.title,
    description: p.data.description,
    date: p.data.date.toISOString(),
    featured: p.data.featured || false,
    link: p.data.link || null,
    repo: p.data.repo || null,
    _url: `/projects/${p.id}`
  })),
  links: links.map(l => ({
    id: l.id,
    title: l.data.title,
    url: l.data.url,
    date: l.data.date.toISOString(),
    tags: l.data.tags || [],
    _url: `/links/${l.id}`
  }))
};

const schema = {
  blog: ['id', 'title', 'description', 'date', 'tags'],
  projects: ['id', 'title', 'description', 'date', 'featured', 'link', 'repo'],
  links: ['id', 'title', 'url', 'date', 'tags']
};

const instanceId = `q-${Math.random().toString(36).slice(2, 9)}`;
---

<div class="query-block" data-instance={instanceId}>
  <div class="query-hint">// query the site</div>
  <div class="query-line">
    <span class="prompt">SELECT</span>
  <input
    type="text"
    class="query-input"
    placeholder={placeholder}
    autocomplete="off"
    spellcheck="false"
  />
  <button class="run-btn" title="Run (Enter)">â–¶</button>
    <div class="autocomplete hidden"></div>
  </div>
</div>

<style>
  .query-block {
    font-family: var(--font-mono);
    font-size: 13px;
  }

  .query-hint {
    color: var(--color-comment);
    font-size: 11px;
    margin-bottom: 2px;
    opacity: 0.7;
  }

  .query-line {
    display: flex;
    align-items: center;
    font-family: var(--font-mono);
    font-size: 13px;
    line-height: 1.6;
    position: relative;
    gap: 0.5em;
  }

  .prompt {
    color: var(--color-keyword);
    user-select: none;
  }

  .query-input {
    flex: 1;
    background: transparent;
    border: none;
    outline: none;
    font-family: inherit;
    font-size: inherit;
    color: var(--color-text);
    caret-color: var(--color-accent);
    padding: 0;
    min-width: 100px;
  }

  .query-input::placeholder {
    color: var(--color-text-muted);
    opacity: 0.4;
  }

  .run-btn {
    background: transparent;
    border: none;
    color: var(--color-text-muted);
    cursor: pointer;
    font-size: 10px;
    padding: 2px 6px;
    opacity: 0;
    transition: opacity 0.15s, color 0.15s;
  }

  .query-line:hover .run-btn,
  .query-input:focus ~ .run-btn {
    opacity: 0.6;
  }

  .run-btn:hover {
    opacity: 1 !important;
    color: var(--color-string);
  }

  .autocomplete {
    position: absolute;
    top: 100%;
    left: 3em;
    background-color: var(--color-bg-panel);
    border: 1px solid var(--color-border);
    border-radius: 4px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    max-height: 160px;
    overflow-y: auto;
    z-index: 100;
    min-width: 180px;
    margin-top: 4px;
  }

  .autocomplete.hidden { display: none; }

  .autocomplete-item {
    padding: 6px 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
  }

  .autocomplete-item:hover,
  .autocomplete-item.selected {
    background-color: var(--color-bg-active);
    color: var(--color-text-bright);
  }

  .autocomplete-item .type {
    font-size: 9px;
    padding: 1px 5px;
    border-radius: 2px;
    text-transform: uppercase;
    font-weight: 500;
  }

  .type.table { background: var(--color-keyword); color: white; }
  .type.column { background: var(--color-function); color: black; }
  .type.keyword { background: var(--color-string); color: white; }
</style>

<script define:vars={{ contentData, schema, instanceId }}>
  class SQLEngine {
    constructor(data, schema) {
      this.data = data;
      this.schema = schema;
      this.tables = Object.keys(data);
    }

    parse(query) {
      const full = 'SELECT ' + query.trim();
      const r = { columns: [], table: null, where: [], orderBy: null, orderDir: 'ASC', limit: null, error: null };

      try {
        const m = full.match(/SELECT\s+(.+?)\s+FROM\s+(\w+)/i);
        if (!m) { r.error = 'Try: * FROM blog'; return r; }

        r.columns = m[1].trim() === '*' ? ['*'] : m[1].split(',').map(c => c.trim());
        r.table = m[2].toLowerCase();
        if (!this.tables.includes(r.table)) { r.error = `No table "${r.table}". Use: ${this.tables.join(', ')}`; return r; }

        const w = full.match(/WHERE\s+(.+?)(?:\s+ORDER|\s+LIMIT|$)/i);
        if (w) r.where = this.parseWhere(w[1]);

        const o = full.match(/ORDER\s+BY\s+(\w+)(?:\s+(ASC|DESC))?/i);
        if (o) { r.orderBy = o[1]; r.orderDir = (o[2] || 'ASC').toUpperCase(); }

        const l = full.match(/LIMIT\s+(\d+)/i);
        if (l) r.limit = parseInt(l[1]);
      } catch (e) { r.error = e.message; }
      return r;
    }

    parseWhere(str) {
      const conds = [];
      for (const part of str.split(/\s+AND\s+/i)) {
        const eq = part.match(/(\w+)\s*=\s*'([^']+)'|(\w+)\s*=\s*(\w+)/i);
        const inM = part.match(/(\w+)\s+IN\s*\(([^)]+)\)/i);
        const like = part.match(/(\w+)\s+LIKE\s+'([^']+)'/i);
        if (inM) conds.push({ col: inM[1], op: 'IN', val: inM[2].split(',').map(v => v.trim().replace(/'/g, '')) });
        else if (like) conds.push({ col: like[1], op: 'LIKE', val: like[2] });
        else if (eq) {
          let v = eq[2] || eq[4];
          if (v === 'true') v = true; else if (v === 'false') v = false;
          conds.push({ col: eq[1] || eq[3], op: '=', val: v });
        }
      }
      return conds;
    }

    execute(p) {
      if (p.error) return { error: p.error };
      let rows = [...this.data[p.table]];
      const cols = p.columns[0] === '*' ? this.schema[p.table] : p.columns;

      for (const c of p.where) {
        rows = rows.filter(row => {
          const v = row[c.col];
          if (c.op === '=') return Array.isArray(v) ? v.includes(c.val) : v === c.val || String(v) === String(c.val);
          if (c.op === 'IN') return Array.isArray(v) ? c.val.some(x => v.includes(x)) : c.val.includes(String(v));
          if (c.op === 'LIKE') return new RegExp(c.val.replace(/%/g, '.*'), 'i').test(String(v));
          return true;
        });
      }

      if (p.orderBy) rows.sort((a, b) => {
        let av = a[p.orderBy], bv = b[p.orderBy];
        if (p.orderBy === 'date') { av = new Date(av).getTime(); bv = new Date(bv).getTime(); }
        return av < bv ? (p.orderDir === 'ASC' ? -1 : 1) : av > bv ? (p.orderDir === 'ASC' ? 1 : -1) : 0;
      });

      if (p.limit) rows = rows.slice(0, p.limit);
      return { rows: rows.map(r => ({ _url: r._url, ...Object.fromEntries(cols.map(c => [c, r[c]])) })), columns: cols, table: p.table };
    }

    suggest(query, pos) {
      const before = query.substring(0, pos).toLowerCase();
      const last = before.split(/\s+/).pop() || '';
      const hasFrom = /from\s*$/i.test(before);
      const hasTable = /from\s+\w+/i.test(before);
      const tbl = before.match(/from\s+(\w+)/i)?.[1];
      const afterWhere = /where\s+\w*$/i.test(before);
      const needsKw = /from\s+\w+\s*$/i.test(before);

      const s = [];
      if (hasFrom && !hasTable) this.tables.forEach(t => s.push({ text: t, type: 'table' }));
      else if (afterWhere && tbl) (this.schema[tbl] || []).forEach(c => s.push({ text: c, type: 'column' }));
      else if (needsKw) ['WHERE', 'ORDER BY', 'LIMIT'].forEach(k => s.push({ text: k, type: 'keyword' }));
      else if (!hasTable) {
        s.push({ text: '* FROM blog', type: 'keyword' });
        s.push({ text: '* FROM projects', type: 'keyword' });
        s.push({ text: '* FROM links', type: 'keyword' });
      }
      return s.slice(0, 6);
    }
  }

  const engine = new SQLEngine(contentData, schema);
  const container = document.querySelector(`[data-instance="${instanceId}"]`);
  const input = container?.querySelector('.query-input');
  const runBtn = container?.querySelector('.run-btn');
  const dropdown = container?.querySelector('.autocomplete');

  let selIdx = -1, suggestions = [];

  function showAC() {
    suggestions = engine.suggest(input.value, input.selectionStart);
    if (!suggestions.length) { dropdown.classList.add('hidden'); return; }
    dropdown.innerHTML = suggestions.map((s, i) =>
      `<div class="autocomplete-item ${i === selIdx ? 'selected' : ''}" data-i="${i}">
        <span class="type ${s.type}">${s.type}</span><span>${s.text}</span>
      </div>`
    ).join('');
    dropdown.classList.remove('hidden');
    dropdown.querySelectorAll('.autocomplete-item').forEach(el => el.onclick = () => applySug(+el.dataset.i));
  }

  function applySug(i) {
    const s = suggestions[i]; if (!s) return;
    const before = input.value.substring(0, input.selectionStart);
    const after = input.value.substring(input.selectionStart);
    const last = before.match(/(\S*)$/)?.[1] || '';
    input.value = before.slice(0, -last.length) + s.text + ' ' + after;
    dropdown.classList.add('hidden');
    selIdx = -1;
    input.focus();
  }

  function runQuery() {
    const q = input.value.trim();
    if (!q) return;
    const parsed = engine.parse(q);
    const result = engine.execute(parsed);

    // Send to OutputPanel via custom event
    window.dispatchEvent(new CustomEvent('query-result', {
      detail: {
        query: 'SELECT ' + q,
        ...result
      }
    }));
  }

  input?.addEventListener('input', () => { selIdx = -1; showAC(); });
  input?.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      if (selIdx >= 0) applySug(selIdx);
      else { dropdown.classList.add('hidden'); runQuery(); }
    } else if (e.key === 'Tab' && suggestions.length) {
      e.preventDefault(); applySug(selIdx >= 0 ? selIdx : 0);
    } else if (e.key === 'ArrowDown') {
      e.preventDefault(); selIdx = Math.min(selIdx + 1, suggestions.length - 1); showAC();
    } else if (e.key === 'ArrowUp') {
      e.preventDefault(); selIdx = Math.max(selIdx - 1, -1); showAC();
    } else if (e.key === 'Escape') { dropdown.classList.add('hidden'); selIdx = -1; }
  });

  runBtn?.addEventListener('click', () => { dropdown.classList.add('hidden'); runQuery(); });
  document.addEventListener('click', (e) => { if (!e.target.closest(`[data-instance="${instanceId}"]`)) dropdown.classList.add('hidden'); });
</script>
